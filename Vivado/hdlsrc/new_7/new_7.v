// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\new_7\new_7.v
// Created: 2025-06-24 11:26:22
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// output_re                     ce_out        1
// output_im                     ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: new_7
// Source Path: new_7
// Hierarchy Level: 0
// Model version: 1.3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module new_7
          (clk,
           reset_x,
           clk_enable,
           input_re,
           input_im,
           enable_1,
           ce_out,
           output_re,
           output_im);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   signed [7:0] input_re;  // sfix8_En6
  input   signed [7:0] input_im;  // sfix8_En6
  input   enable_1;
  output  ce_out;
  output  signed [7:0] output_re;  // sfix8_En6
  output  signed [7:0] output_im;  // sfix8_En6


  wire enb;
  wire [7:0] data_length_out1;  // uint8
  wire out;
  wire we;
  wire [7:0] count_step;  // uint8
  wire [7:0] count_from;  // uint8
  wire [7:0] count_reset;  // uint8
  reg [7:0] addr;  // uint8
  wire [7:0] count;  // uint8
  wire need_to_wrap;
  wire [7:0] count_value;  // uint8
  wire [7:0] count_1;  // uint8
  wire [7:0] count_2;  // uint8
  wire [7:0] count_step_1;  // uint8
  wire [7:0] count_from_1;  // uint8
  wire [7:0] count_reset_1;  // uint8
  reg [7:0] addr_op;  // uint8
  wire [7:0] count_3;  // uint8
  wire need_to_wrap_1;
  wire [7:0] count_value_1;  // uint8
  wire open;
  wire Logical_Operator1_out1;
  wire [7:0] count_4;  // uint8
  wire [7:0] count_5;  // uint8
  wire [7:0] main_module_new_out3;  // uint8
  wire ready;


  assign data_length_out1 = 8'b01100100;

  enable u_enable (.clk(clk),
                   .reset_x(reset_x),
                   .enb(clk_enable),
                   .enable_1(enable_1),
                   .length(data_length_out1),  // uint8
                   .out(out)
                   );

  assign we =  ~ out;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step = 8'b00000001;

  assign count_from = 8'b00000000;

  assign count_reset = 8'b00000000;

  assign enb = clk_enable;

  assign count = addr + count_step;

  assign need_to_wrap = addr == 8'b11111111;

  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);

  assign count_1 = (we == 1'b0 ? addr :
              count_value);

  assign count_2 = (out == 1'b0 ? count_1 :
              count_reset);

  always @(posedge clk)
    begin : addr_Counter_process
      if (reset_x == 1'b1) begin
        addr <= 8'b00000000;
      end
      else begin
        if (enb) begin
          addr <= count_2;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step_1 = 8'b00000001;

  assign count_from_1 = 8'b00000000;

  assign count_reset_1 = 8'b00000000;

  assign count_3 = addr_op + count_step_1;

  assign need_to_wrap_1 = addr_op == 8'b11111111;

  assign count_value_1 = (need_to_wrap_1 == 1'b0 ? count_3 :
              count_from_1);

  assign Logical_Operator1_out1 =  ~ open;

  assign count_4 = (Logical_Operator1_out1 == 1'b0 ? addr_op :
              count_value_1);

  assign count_5 = (open == 1'b0 ? count_4 :
              count_reset_1);

  always @(posedge clk)
    begin : op_addr_Counter_process
      if (reset_x == 1'b1) begin
        addr_op <= 8'b00000000;
      end
      else begin
        if (enb) begin
          addr_op <= count_5;
        end
      end
    end

  enable2 u_enable2 (.clk(clk),
                     .reset_x(reset_x),
                     .enb(clk_enable),
                     .length(main_module_new_out3),  // uint8
                     .ready(ready),
                     .open(open)
                     );

  main_module_new u_main_module_new (.clk(clk),
                                     .reset_x(reset_x),
                                     .enb(clk_enable),
                                     .input_re(input_re),  // sfix8_En6
                                     .input_im(input_im),  // sfix8_En6
                                     .addr(addr),  // uint8
                                     .length(data_length_out1),  // uint8
                                     .we(we),
                                     .en(out),
                                     .open(open),
                                     .ren(open),
                                     .op_addr(addr_op),  // uint8
                                     .output2_re(output_re),  // sfix8_En6
                                     .output2_im(output_im),  // sfix8_En6
                                     .ready(ready),
                                     .length1(main_module_new_out3)  // uint8
                                     );

  assign ce_out = clk_enable;

endmodule  // new_7

