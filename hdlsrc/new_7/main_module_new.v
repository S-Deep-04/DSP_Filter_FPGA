// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\new_7\main_module_new.v
// Created: 2025-06-24 11:26:22
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: main_module_new
// Source Path: new_7/main _module_new
// Hierarchy Level: 1
// Model version: 1.3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module main_module_new
          (clk,
           reset_x,
           enb,
           input_re,
           input_im,
           addr,
           length,
           we,
           en,
           open,
           ren,
           op_addr,
           output2_re,
           output2_im,
           ready,
           length1);


  input   clk;
  input   reset_x;
  input   enb;
  input   signed [7:0] input_re;  // sfix8_En6
  input   signed [7:0] input_im;  // sfix8_En6
  input   [7:0] addr;  // uint8
  input   [7:0] length;  // uint8
  input   we;
  input   en;
  input   open;
  input   ren;
  input   [7:0] op_addr;  // uint8
  output  signed [7:0] output2_re;  // sfix8_En6
  output  signed [7:0] output2_im;  // sfix8_En6
  output  ready;
  output  [7:0] length1;  // uint8


  wire switch_compare_1;
  wire we_1;
  wire Logical_Operator3_out1;
  wire [7:0] count_step;  // uint8
  wire [7:0] count_from;  // uint8
  wire [7:0] count_reset;  // uint8
  reg [7:0] addr_1;  // uint8
  wire [7:0] count;  // uint8
  wire need_to_wrap;
  wire [7:0] count_value;  // uint8
  wire [7:0] count_1;  // uint8
  wire [7:0] count_2;  // uint8
  wire [7:0] mux_addr_out1;  // uint8
  wire switch_compare_1_1;
  wire we1;
  wire signed [7:0] oaa_re;  // sfix8_En6
  wire signed [7:0] oaa_im;  // sfix8_En6
  wire Logical_Operator2_out1;
  reg  daa;
  wire signed [7:0] Product_in1;  // sfix8_En6
  wire signed [8:0] Product_cast;  // sfix9_En6
  wire signed [7:0] Product_in1_1;  // sfix8_En6
  wire signed [8:0] Product_cast_1;  // sfix9_En6
  wire signed [7:0] o1_re;  // sfix8_En6
  wire signed [7:0] o1_im;  // sfix8_En6
  wire signed [7:0] output_re;  // sfix8_En6
  wire signed [7:0] output_im;  // sfix8_En6
  wire switch_compare_1_2;
  wire we2;
  wire Logical_Operator4_out1;
  wire [7:0] count_step_1;  // uint8
  wire [7:0] count_from_1;  // uint8
  wire [7:0] count_reset_1;  // uint8
  reg [7:0] addr_2;  // uint8
  wire [7:0] count_3;  // uint8
  wire need_to_wrap_1;
  wire [7:0] count_value_1;  // uint8
  wire [7:0] count_4;  // uint8
  wire [7:0] count_5;  // uint8
  wire [7:0] addr_2_1;  // uint8
  wire switch_compare_1_3;
  wire we2_1;
  wire signed [7:0] output_re_1;  // sfix8_En6
  wire signed [7:0] output_im_1;  // sfix8_En6
  reg  Delay1_out1;
  wire signed [7:0] Product1_in1;  // sfix8_En6
  wire signed [8:0] Product1_cast;  // sfix9_En6
  wire signed [7:0] Product1_in1_1;  // sfix8_En6
  wire signed [8:0] Product1_cast_1;  // sfix9_En6


  assign switch_compare_1 = en > 1'b0;

  Chart u_Chart (.clk(clk),
                 .reset_x(reset_x),
                 .enb(enb),
                 .en(en),
                 .length(length),  // uint8
                 .we(we_1)
                 );

  assign Logical_Operator3_out1 =  ~ we_1;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step = 8'b00000001;

  assign count_from = 8'b00000000;

  assign count_reset = 8'b00000000;

  assign count = addr_1 + count_step;

  assign need_to_wrap = addr_1 == 8'b11111111;

  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);

  assign count_1 = (Logical_Operator3_out1 == 1'b0 ? addr_1 :
              count_value);

  assign count_2 = (we_1 == 1'b0 ? count_1 :
              count_reset);

  always @(posedge clk)
    begin : addr_Counter_process
      if (reset_x == 1'b1) begin
        addr_1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          addr_1 <= count_2;
        end
      end
    end

  assign mux_addr_out1 = (switch_compare_1 == 1'b0 ? addr :
              addr_1);

  assign switch_compare_1_1 = en > 1'b0;

  assign we1 = (switch_compare_1_1 == 1'b0 ? we :
              we_1);

  SinglePortRAM_generic #(.AddrWidth(8),
                          .DataWidth(8)
                          )
                        u_Single_Port_RAM (.clk(clk),
                                           .enb(enb),
                                           .din_re(input_re),
                                           .din_im(input_im),
                                           .addr(mux_addr_out1),
                                           .we(we1),
                                           .dout_re(oaa_re),
                                           .dout_im(oaa_im)
                                           );

  assign Logical_Operator2_out1 =  ~ we1;

  always @(posedge clk)
    begin : delay_process
      if (reset_x == 1'b1) begin
        daa <= 1'b0;
      end
      else begin
        if (enb) begin
          daa <= Logical_Operator2_out1;
        end
      end
    end

  assign Product_in1 = (daa == 1'b1 ? oaa_re :
              8'sb00000000);
  assign Product_cast = {Product_in1[7], Product_in1};
  assign o1_re = Product_cast[7:0];
  assign Product_in1_1 = (daa == 1'b1 ? oaa_im :
              8'sb00000000);
  assign Product_cast_1 = {Product_in1_1[7], Product_in1_1};
  assign o1_im = Product_cast_1[7:0];

  FIR_system_new u_FIR_system_new (.clk(clk),
                                   .reset_x(reset_x),
                                   .enb(enb),
                                   .o1_re(o1_re),  // sfix8_En6
                                   .o1_im(o1_im),  // sfix8_En6
                                   .output_re(output_re),  // sfix8_En6
                                   .output_im(output_im)  // sfix8_En6
                                   );

  assign switch_compare_1_2 = open > 1'b0;

  Chart1 u_Chart1 (.clk(clk),
                   .reset_x(reset_x),
                   .enb(enb),
                   .en(en),
                   .length(length),  // uint8
                   .ready(ready),
                   .we2(we2)
                   );

  assign Logical_Operator4_out1 =  ~ we2;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step_1 = 8'b00000001;

  assign count_from_1 = 8'b00000000;

  assign count_reset_1 = 8'b00000000;

  assign count_3 = addr_2 + count_step_1;

  assign need_to_wrap_1 = addr_2 == 8'b11111111;

  assign count_value_1 = (need_to_wrap_1 == 1'b0 ? count_3 :
              count_from_1);

  assign count_4 = (we2 == 1'b0 ? addr_2 :
              count_value_1);

  assign count_5 = (Logical_Operator4_out1 == 1'b0 ? count_4 :
              count_reset_1);

  always @(posedge clk)
    begin : addr_Counter2_process
      if (reset_x == 1'b1) begin
        addr_2 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          addr_2 <= count_5;
        end
      end
    end

  assign addr_2_1 = (switch_compare_1_2 == 1'b0 ? op_addr :
              addr_2);

  assign switch_compare_1_3 = open > 1'b0;

  assign we2_1 = (switch_compare_1_3 == 1'b0 ? ren :
              we2);

  SinglePortRAM_generic #(.AddrWidth(8),
                          .DataWidth(8)
                          )
                        u_Single_Port_RAM1 (.clk(clk),
                                            .enb(enb),
                                            .din_re(output_re),
                                            .din_im(output_im),
                                            .addr(addr_2_1),
                                            .we(we2_1),
                                            .dout_re(output_re_1),
                                            .dout_im(output_im_1)
                                            );

  always @(posedge clk)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Logical_Operator4_out1;
        end
      end
    end

  assign Product1_in1 = (Delay1_out1 == 1'b1 ? output_re_1 :
              8'sb00000000);
  assign Product1_cast = {Product1_in1[7], Product1_in1};
  assign output2_re = Product1_cast[7:0];
  assign Product1_in1_1 = (Delay1_out1 == 1'b1 ? output_im_1 :
              8'sb00000000);
  assign Product1_cast_1 = {Product1_in1_1[7], Product1_in1_1};
  assign output2_im = Product1_cast_1[7:0];

  assign length1 = length;

endmodule  // main_module_new

